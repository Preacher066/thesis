\chapter{Path selection} \label{chap:steiner}

%\section{Subproblems}

Our approach to a better heuristics
is driven by the concept of location graph and using the same for
construction of low latency tours of the MULEs in data collection phase. 
Two critical subproblems encountered in this context are: 
(i) Euclidean Minimum Stiener Tree (EMST), and (ii)  Euclidean Travelling Saleman Problem (ETSP). Both the problems have already been introduced
in chapter~\ref{chapter2}. We will briefly restate these here for
sake of completeness and convenience in description of our heuristics.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{definition}{Euclidean Travelling Salesman Problem}
Given a set of n 2D points in a plane find a minimum cost tour of all
the points, visiting every point exactly once.
\end{definition}
We use Christofides algorithm~\cite{christofides} as the approximation 
heuristic for computing TSP route of a set of points.

{\bf Comment:} I believe these subproblem are independent concepts. 
So, these should be introduced in chapter 2 little more elaborately
with adequate nontrivial examples.


\begin{definition}{Euclidean minimum Steiner Tree problem}
Given a set $P$ of points in a 2-D plane as input, the output is a network of line segements connecting all of the points in $S$, with the smallest total (Euclidean) length.
\end{definition}
The line segments making the Steiner Tree need just be incident on the 
points in $S$. This implies that the algorithm is free to use additional 
points from the plane, if necessary, to produce the smallest total length 
network. The additional points are called {\em Steiner Points}.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The location nodes (the nodes in location graph) computed earlier, form 
the set $P$, and the EMST is generated using the set $P$.
The pseudo code for the heuristic
which appear later in section~\ref{sec:heuristicAlgo} this chapter use 
the EMST as input. The choice of EMST as data structure over MST is 
guided by the fact that the goal of our heuristic to divide the set of location nodes into multiple sets with approximately the same TSP time units.
The TSP time unit is the time taken by a MULE to visit all points on EMST.
the cost of ETSP on a set is atmost twice the cost of the EMST on it. Therefore, it should be reasonable to use the Steiner tree traversal as a guide for partitioning. Furthermore, in the case where the field also includes obstacles, Steiner trees lend themselves naturally to cover all the points due the properties of Steiner points~\cite{oaest99} as explained in 
section~\ref{sec:steinerPoint} of chatper~2. Though we plan not to cover the obstacle avoidance case, we briefly sketch the underlying ideas in 
Chapter~\ref{chap:concl}.
For computing Steiner tress, we use the exact solution finder software 
GeoSteiner~\cite{geosteiner1}~\cite{geosteiner2}~\cite{geosteiner3}. 

{\bf Comment:} Here you could show a Steiner tree generated by
GeoSteiner. 

\section{Path Selection Heuristic}

%\subsection{Aim}
The aim of path selection heuristic is to find a minimum partitioning of
the set of location nodes of a location graph by addition of 
extra Steiner points such that following conditions are satisfied.

\begin{itemize}
\item Each of the subsets has a TSP tour length (in units of time) less than a per-specified value $L$, and for any two sets $S_{i}$ and $S_{j}$, $S_{i} \cap S_{j} \le 1$.
\item Let $V$ be the set of all subsets $S_{i}$. Let $E$ be the set of pairs of subsets $(S_{i},S_{j})$ such that $S_{i} \cap S_{j} = 1$. Then the graph $G(V,E)$ should be a connected graph.
\end{itemize}

It assumed that the time a MULE spends in a network while collecting data
consists of three main components: (i) travelling from one location node to another $t_{TSP}$, (ii) talking to sensors belonging to a location node $t_{LS}$, (iii) talking to other MULEs/Base station $t_{MBS}$. Obviously, the 
contribution due to last two components of a MULE's operation remains
the same for in any subset of location nodes assigned to the same MULE. 
Furthermore, both $t_{LS}$ and $t_{MBS}$ are small compared to $t_{TSP}$. 

We first describe the algorithm for a simplified heuristic that ignores the last two components of a MULE's, namely, $t_{LS}$ and $t_{MBS}$. Subsequently, we modify the above algorithm to take into account the second component of time $t_{LS}$. We assume that MULE to MULE data transfer times are shorterdue to two reasons, namely, (i) MULEs may use data aggregation while sending data to fellow a MULE or BS, and (ii) MULEs being relative expensive and more robust than sensor node, typically have higher bandwidth for inter MULE data transfer. The component $t_{LS}$ for each location node can be given as an input, or observed before running the heuristic, by simply sending one MULE on a tour of all the location nodes in the field to measure and record such times beforehand.


\subsection{Simplified Heuristics}

The overall strategy is to create an EMST of the location nodes and then divide this tree into subgraphs, using the tree edges as the guide. Each subgraph's set of vertices will be covered by one MULE (henceforth, this set of nodes will be called a subtour), and the subgraph's weight will be our estimate of how long will a MULE take to cover it.

{\bf Comment:} Weight of EMST is not defined. How weight is linked to
tour length? Where do you plan to provide theorem details? Clearly,
theorem's proof appears else where. So you need to provide proper
references and may state the theorem without proof. Similarly property
of EMST must also be mentioned elsewhere and reference can be made.
Please do not use "vertices" when in most of the text you are using
term "nodes".

Due to the theorem~\ref{theo:1}, the length of the TSP tour of a set of 2D points is at most twice the weight of their EMST. Also from the property~1
stated in section~\ref{sec:EMST} of Chapter~2, any connected subgraph of an EMST is also the EMST of the constituent nodes.

We now describe the algorithm that will not take in to account $t_{LS}$,and will be used to generate simulation results. Given any tree $T$, we start from the given root node $root$. $root$ then becomes the current node $curr$. Then following steps of Prim's algorithm~\cite{Prim}, we first mark $curr$ as visited, then we insert all the incident edges of the current node with unvisited nodes to the min-heap $edgeHeap$. Computation of a tour for a MULE consists of two stages coded in two inner while loops.

In the first stage, represented by the first inner while loop, every time we an edge $(v1,v2)$ is selected and delete from $edgeHeap$, all the edges incident to $v1$ which have unvisited end nodes are inserted into the heap. Then, $v1$ is inserted to $currSet$. We keep popping edges from $edgeHeap$ until either $edgeHeap$ becomes empty or, adding any more edges to $currSet$ from $edgeHeap$ leads to total weight exceeding $\frac{L}{hApprox}$. Note that the second condition ensures that the TSP weight of our points set $currSet$ does not exceed $L$. The bound for $L_{hApprox}$ depends completely upon the heuristic used for TSP problem, which is approximation ratio of the heuristic used for TSP, $\times$ 2 ({\bf comment: what is it?}). If an optimal algorithm can be found then the bound will be exactly 2, because the optimal TSP length of  a set of 2D points is bounded by 2 $\times$ the total length of their EMST. Since we have used Christofides heuristic~\cite{christofides} for TSP, whose approximation ratio is $\frac{3}{2}$, $hApprox$ is 3.

Any Steiner point whose all adjacent nodes belong to same subtour will useless. Because, such a Steiner point neither serves as a connecting node between different subtours, nor represents a location node. So, such a Steiner point should be eliminated form the subtour. Function $cleanTour$ is used precisely for this purpose. {\bf comments: what does the next sentence supposed to mean?} Every time we test the inclusion of a new edge in the second stage.

Actual calculation of TSP of the selected node set is performed in the second stage while  %we calculate the actual TSP of our point set and 
continuing popping of edges from $edgeHeap$ and adding these to $currSet$. Before adding a node to $currSet$, we test whether its inclusion will make $currT$ exceed $L$ or not. If yes, then $currSet$ is the final node set for this MULE. Otherwise, the second inner while loop repeats. %until hen our $currSet$ for this MULE is final. 
The edge records still left in the Heap, after completion of one full iteration of the second inner while loop, form the boundary of the nodes in $currSet$. We call this set as $i$th after completion of $i$th iteration of the loop. %  with respect to the Steiner tree, 
These nodes are pushed in the $boundary$, from where the next $root$ for the next MULE's is chosen.% point set to cover, 


\begin{algorithm}
\caption{Dividing the set nodes of a given Steiner tree into subsets of bounded TSP time}\label{euclid}
\begin{algorithmic}
\Function{greedySteiner}{A Steiner tree $T$ of 2D points in a plane, Starting vertex $root$, desired upper bound on latency $L$}\Comment{this function returns S: Set of tours, each with touring time $\le$ L}
\State Set  $S$
\State $N \gets$ number of vertices in T
\State $queue$ boundary.push($root$) 
\State $bool$ $visited[N]$
\State $vertex$ curr 
\For{$i \gets 1,N$}
	\State $visited[i] \gets false$ 
\EndFor
\While{1}
	\If{boundary.empty()}
		\State break
	\EndIf
	\State $currT \gets 0.0$ 
	\State $hApprox \gets 0.5$ 
	\State $cycleWeight \gets 0.0$ 
	\State Min\_heap $edgeHeap$  
	\State $curr \gets root$ 
	\State Set $currSet$, $tempSet$ 
	\State $visited[curr] \gets true$ 
	\State Set $U \gets$ all unvisited vertices adjacent to $cur$ 
	\ForAll{ vertex $v$ in U}
		\State $edgeHeap$.push(dist($v$,$curr$), ($v$,$curr$)) 
	\EndFor

	\State $currSet$.insert($curr$) 
	\While{$\neg$ edgeHeap.empty()}
		\State $nextWeight \gets edgeHeap$.top().first 
		\State $currT \gets currT + nextWeight$ 
		\If{$currT \geq hApprox \times L$}
			break 
		\EndIf
		\State $curr \gets edgeHeap$.top().second.first 
		\State $currSet.insert(curr)$ 
		\State $visited[curr] \gets true$ 
		\State $edgeHeap$.pop() 
		\State $U$.clear() 
		\State $U \gets$ all unvisited vertices adjacent to $cur$ 
		\ForAll{ vertex $v$ in $U$}
			\State $edgeHeap$.push(dist($v$,$curr$), ($v$,$curr$)) 
		\EndFor
	\EndWhile

	\State $cleanTour(currSet)$
\algstore{pag}
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\begin{algorithmic}
\algrestore{pag}
	
	\State Tour $currTour$ 
	\State $tempSet \gets currSet$ 
	\State $cycleWeight , currTour \gets TSPCircuit(tempSet)$

	\While{$\neg$ edgeHeap.empty() and cycleWeight $<$ $L$}
		\State $curr \gets edgeHeap$.top().second.first 
		\State tempSet.insert(curr);
		\State $cleanTour(tempSet)$
		\State $cycleWeight, currTour \gets TSPCircuit(tempSet)$ 
		\If{$cycleWeight$ $>$ $L$}
			\State break 
		\EndIf
		\State currSet.insert($curr$);
		\State $visited[curr] \gets true$ 
		\State edgeHeap.pop() 
		\State $U$.clear() 
		\State $U  \gets$ all unvisited vertices adjacent to $cur$ 
		\ForAll{ vertex $v$ in U}
			\State edgeHeap.push(dist($v$,$curr$), ($v$,$curr$)) 
		\EndFor
	\EndWhile
	
	\State $S$.insert($currTour$) 

	\While{$\neg$ heap.empty()}
		\State $edge$ $e$ = $edgeHeap$.top().second;
		\State $boundary$.push($e$.second);
		\State $edgeHeap$.pop();
	\EndWhile
	
	\If{$boundary$.empty()}
		\State return false 
	\EndIf

\EndWhile
\EndFunction

\Function{cleanTour}{$vSet$ : the set of vertices in the current tour}
	\Comment{Delete all Steiner vertices from $vSet$, whose all adjacent verices are in $vSet$ itself.}
\EndFunction

\end{algorithmic}
\end{algorithm}

\pagebreak
\subsection{Modified Heuristics}

{\bf Comments: give only a description of modification in algorithm. Do not
restate the steps completely.}

Let us now modify the simplified algorithm to into account the time $t_{LS}$. Given any tree $T$, we start from the given root node $root$. Node $root$ then becomes the current node $curr$. Then as in the case of first algorithm, we first mark $curr$ as visited, and insert all the incident edges (to the current node) with unvisited node to the AVL tree $edgeRecords$. There are two stages for computation of a tour for a MULE, represented by 2 inner while loops.

The first stage is represented by the first inner while loop. It iteratively selects and deletes an edge $(v1,v2)$ from $edgeRecords$, and insert each  edge incident to $v1$ that has an unvisited nodes as the second end point. Finally, $v1$ is inserted into $currSet$. The above set of three operations are performed iteratively %we keep selecting and deleting edges from $edgeRecords$ 
{\bf Comments: I am lost here. weight refers to length of edges. But now
  we have weight of a node. Note currSet is only a set of nodes not a set of
edges. Description here needs cleaning} 
until either $edgeRecords$ becomes empty, or adding one more edge from $edgeRecords$ to $currSet$ makes weight of $currT$ (($hApprox\times$ the sum of weights of the edges in $currSet$) + the sum of weights of unique nodes in $currSet$) exceeds $\frac{L}{hApprox}$.

Again, any Steiner point whose all adjacent vertices belong to same subtour are deleted, in same conditions as in Algorithm 1. In the second stage, we calculate the actual TSP of our point set and look for the smallest weighted record (the triplet of adjacent vertex weight, edge length, and the edge itelf) to add. Before adding it to $currSet$, we test whether its inclusion will make $currT$ exceed $L$ or not. If yes, $currSet$ is our final point set for this MULE, otherwise, we repeat the second inner while loop until we do, and then our $currSet$ for this MULE is final. The edge records still left in the AVL tree form the boundary of the vertices in $currSet$ ith resoect to the Steiner tree, which are pushed in the $boundary$, from where our next $root$ for next MULE's point set to cover, is chosen.

\begin{algorithm}
\caption{Dividing the set vertices of a given Steiner tree into subsets of bounded TSP time}\label{euclid2}
\begin{algorithmic}
\Function{greedySteiner}{$T$ : A Steiner tree of 2D points in a plane, $root$ : Starting vertex, $L$ : Desired upper bound on latency, $wArray$ : $wArray[i]$ is weight of the vertex $i$ and Steiner vertices have $0$ weight}\Comment{this function returns S: Set of tours, each with touring time $\le$ L}
\State Set  $S$
\State $N \gets$ number of vertices in T
\State $queue$ boundary.push($root$) 
\State $bool$ $visited[N]$
\State $vertex$ curr 
\For{$i \gets 1,N$}
	\State $visited[i] \gets false$ 
\EndFor
\While{1}
	\If{boundary.empty()}
		\State break
	\EndIf
	\State $currT \gets 0.0$ 
	\State $hApprox \gets 3$ 
	\State $cycleWeight \gets 0.0$ 
	\State AVLTree $edgeRecords$  \Comment{The records are compared by the sum of their first two members}
	\State $curr \gets root$ 
	\State Set $currSet$, $tempSet$ 
	\State $visited[curr] \gets true$ 
	\State Set $U \gets$ all unvisited vertices adjacent to $cur$ 
	\ForAll{ vertex $v$ in U}
		\State $edgeRecords$.insert(wArray[$v$], dist($v$,$curr$), ($v$,$curr$)) 
	\EndFor
	\State $currSet$.insert($curr$) 
	\While{$edgeRecords$ is not empty}
		\State $nRecord \gets nextRecord((L-currT),edgeRecord,hApprox)$
		\State $currT \gets currT + nRecord.first + hApprox \times nRecord$.second 
		\If{$currT \geq L$}
			break 
		\EndIf
		\State $curr \gets nRecord.third.first$
		\State $currSet.insert(curr)$ 
		\State $visited[curr] \gets true$ 
		\State $edgeRecord.delete(nRecord)$
		\State $U$.clear() 
		\State $U \gets$ all unvisited vertices adjacent to $cur$ 
		\ForAll{ vertex $v$ in $U$}
			\State $edgeRecords$.insert(wArray[$v$], dist($v$,$curr$), ($v$,$curr$)) 
		\EndFor
	\EndWhile
	
	\State $cleanTour(currSet)$
	
\algstore{pag2}
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\begin{algorithmic}
\algrestore{pag2}
	
	\State Tour $currTour$ 
	\State $tempSet \gets currSet$ 
	\State $cycleWeight , currTour \gets TSPCircuit(tempSet)$ \Comment{$cycleWeight$ includes the location nodes' weights}

	\While{$\neg$ edgeRecords.empty() and $cycleWeight < L$}
		\State $nRecord \gets nextRecord((L-currT),edgeRecord,hApprox)$
		\State $tempSet$.insert($curr$);
		\State $cleanTour(tempSet)$
		\State $cycleWeight, currTour \gets TSPCircuit(tempSet)$ 
		\If{$cycleWeight > L$}
			\State break 
		\EndIf
		\State currSet.insert($curr$);
		\State $visited[curr] \gets true$ 
		\State $edgeRecord.delete(nRecord)$
		\State $U$.clear() 
		\State $U  \gets$ all unvisited vertices adjacent to $cur$ 
		\ForAll{ vertex $v$ in U}
			\State $edgeRecords$.insert(wArray[$v$], dist($v$,$curr$), ($v$,$curr$)) 
		\EndFor
	\EndWhile
	
	\State $S$.insert($currTour$) 
	
	\State $tempSet$.clear()
	
	\ForAll{Record $r$ in $edgeRecords$)}
		\State $tempSet$.insert($r$.third.second);		\Comment{Inserting the boundary vertices in boundary}
	\EndFor

	\ForAll{Vertex $v$ in $tempSet$}
		$boundary$.push($v$)
	\EndFor
	
	\If{$boundary$.empty()}
		\State break
	\EndIf

\EndWhile
\EndFunction

\Function{cleanTour}{$vSet$ : the set of vertices in the current tour}
	\Comment{Delete all Steiner vertices from $vSet$, whose all adjacent verices are in $vSet$ itself.}
\EndFunction

\Function{nextRecord}{$L_R$ : remaining time, $edgeRecords$ : The AVL Tree to search, $hApprox$ : Approximation ratio of the heuristic used for TSP $\times$ 2}
	\Comment{Do an inorder search for the least weighted record r in the tree such that $L_R < (r.first+ hApprox\times r.second)$}
\EndFunction

\end{algorithmic}
\end{algorithm}

\subsection{Scalability restriction and Minimum Latency}
Consider the extreme case of low latency requirement, when 1 MULE is assigned to each edge of the Steiner tree. This must be the smallest latency supportable with this heuristic. Lets call this latency $L_{min}$. Let $w_{max}$ be the larget weight among the wieghts of the edges of the Steiner tree. Then, $L_{min} \ge w_{max}$.
For any edge $(p,q)$ in the current Steiner tree, suppose upon recording the dfs sequence from the base station in the Steiner tree, $p$ appears before $q$; then $p$ is said to be near vertex, and $q$ is said to be the farther vertex. Then, for the case when $t_{LS}$ is not ignored, let $(i,j)$ be the maximum weighted edge with weight $w_{max}$. Also, let j be the farther 
vertex. Then, $L_{min} \ge w_{max}+t_{LS}[j]$.

Consider a single MULE collecting and aggregating all the data from all the sensor networks, and uploading it to the base station. For any sensor distribution, let the time taken by the MULE to upload the data be $T_{MBS}$. Now we will account for $t_{MBS}$. Consider the subtour containing the base station. The MULE assigned to this subtour is responsible for indirectly collecting and aggregating the data from all other subtours and delivering it to the base station. For this, it sends/recieves from other MULEs and the base station for total of $2 \times T_{MBS}$ units of time (simplistic assumption, neglecting time spent in P2P protocol between MULEs). Clearly, for any other subtour, its assigned MULE can not have a $t_{MBS}$ greater than $2 \times T_{MBS}$. So, if $T_{MBS}$ is significant contribution to total time taken by a MULE to cover its subtour, $L_{min} \ge w_{max}+t_{LS}[j]+2 \times T_{MBS}$.
